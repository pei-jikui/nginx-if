
diff --git a/src/http/modules/ngx_http_rewrite_module.c b/src/http/modules/ngx_http_rewrite_module.c
index 0e6d4df..8c39bb5 100644
--- a/src/http/modules/ngx_http_rewrite_module.c
+++ b/src/http/modules/ngx_http_rewrite_module.c
@@ -19,6 +19,10 @@ typedef struct {
     ngx_flag_t    uninitialized_variable_warn;
 } ngx_http_rewrite_loc_conf_t;

+typedef struct {
+    ngx_http_script_if_op_e op_type;
+    ngx_uint_t              op_index;
+} ngx_http_rewrite_if_operator_t;

 static void *ngx_http_rewrite_create_loc_conf(ngx_conf_t *cf);
 static char *ngx_http_rewrite_merge_loc_conf(ngx_conf_t *cf,
@@ -33,12 +37,22 @@ static char *ngx_http_rewrite_if(ngx_conf_t *cf, ngx_command_t *cmd,
     void *conf);
 static char * ngx_http_rewrite_if_condition(ngx_conf_t *cf,
     ngx_http_rewrite_loc_conf_t *lcf);
+
 static char *ngx_http_rewrite_variable(ngx_conf_t *cf,
     ngx_http_rewrite_loc_conf_t *lcf, ngx_str_t *value);
 static char *ngx_http_rewrite_set(ngx_conf_t *cf, ngx_command_t *cmd,
     void *conf);
 static char * ngx_http_rewrite_value(ngx_conf_t *cf,
     ngx_http_rewrite_loc_conf_t *lcf, ngx_str_t *value);
+static char * ngx_http_rewrite_parse_if_condition(ngx_conf_t *cf,
+    ngx_http_rewrite_loc_conf_t *lcf,
+    ngx_str_t *value, ngx_uint_t begin, ngx_uint_t last);
+static char * ngx_http_rewrite_find_if_logic_operator(ngx_str_t * value,
+    ngx_uint_t begin, ngx_uint_t last,
+    ngx_http_rewrite_if_operator_t *operator);
+static char *
+ngx_http_rewrite_if_logic_item(ngx_conf_t *cf, ngx_http_rewrite_loc_conf_t *lcf,
+    ngx_uint_t cur, ngx_uint_t last);


 static ngx_command_t  ngx_http_rewrite_commands[] = {
@@ -642,51 +656,27 @@ ngx_http_rewrite_if(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
     return NGX_CONF_OK;
 }

-
 static char *
-ngx_http_rewrite_if_condition(ngx_conf_t *cf, ngx_http_rewrite_loc_conf_t *lcf)
+ngx_http_rewrite_if_logic_item(ngx_conf_t *cf, ngx_http_rewrite_loc_conf_t *lcf,
+    ngx_uint_t cur, ngx_uint_t last)
 {
     u_char                        *p;
     size_t                         len;
     ngx_str_t                     *value;
-    ngx_uint_t                     cur, last;
     ngx_regex_compile_t            rc;
     ngx_http_script_code_pt       *code;
     ngx_http_script_file_code_t   *fop;
     ngx_http_script_regex_code_t  *regex;
     u_char                         errstr[NGX_MAX_CONF_ERRSTR];

-    value = cf->args->elts;
-    last = cf->args->nelts - 1;
-
-    if (value[1].len < 1 || value[1].data[0] != '(') {
-        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
-                           "invalid condition \"%V\"", &value[1]);
-        return NGX_CONF_ERROR;
-    }
-
-    if (value[1].len == 1) {
-        cur = 2;
-
-    } else {
-        cur = 1;
-        value[1].len--;
-        value[1].data++;
-    }
-
-    if (value[last].len < 1 || value[last].data[value[last].len - 1] != ')') {
+    if (cur > last) {
         ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
-                           "invalid condition \"%V\"", &value[last]);
+                "item begin index %u is larger than the end index %u",
+                cur, last);
         return NGX_CONF_ERROR;
     }

-    if (value[last].len == 1) {
-        last--;
-
-    } else {
-        value[last].len--;
-        value[last].data[value[last].len] = '\0';
-    }
+    value = cf->args->elts;

     len = value[cur].len;
     p = value[cur].data;
@@ -862,6 +852,264 @@ ngx_http_rewrite_if_condition(ngx_conf_t *cf, ngx_http_rewrite_loc_conf_t *lcf)
     return NGX_CONF_ERROR;
 }

+static ngx_http_script_if_op_e
+ngx_http_rewrite_if_check_operator(ngx_str_t *value)
+{
+    if (value == NULL) {
+        return ngx_http_script_if_invalid;
+    }
+    if (value->len == 2) {
+        if (ngx_strncmp(value->data, "||", 2) == 0){
+            return ngx_http_script_if_or;
+        } else if (ngx_strncmp(value->data, "&&", 2) == 0){
+            return ngx_http_script_if_and;
+        }
+    }
+    return ngx_http_script_if_invalid;
+}
+
+static char *
+ngx_http_rewrite_find_if_logic_operator(ngx_str_t * value, ngx_uint_t begin,
+       ngx_uint_t last, ngx_http_rewrite_if_operator_t *operator)
+{
+    ngx_http_script_if_op_e op_type =  ngx_http_script_if_invalid;
+
+    if (value == NULL || begin > last || operator == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    operator->op_type = op_type;
+    operator->op_index = 0;
+    while (begin <= last) {
+        op_type = ngx_http_rewrite_if_check_operator(&value[begin]);
+        if (op_type != ngx_http_script_if_invalid) {
+            operator->op_type = op_type;
+            operator->op_index = begin;
+            return NGX_CONF_OK;
+        }
+        begin ++;
+    }
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_http_rewrite_if_match_bracket(ngx_str_t *value, ngx_uint_t begin,
+        ngx_uint_t last, ngx_uint_t *index)
+{
+    /*When we run into this logic, the first charactore
+     * of the begin must be (
+     * which is guarante before calling this function.*/
+
+    /*The logic is quit simple, when find  a ( then the score
+     * increases by 1 and decreases by 1 if found a ). Will return
+     * if the score is zero which means the ( and ) is matching.
+     */
+
+    ngx_uint_t match_score = 1;
+    ngx_uint_t len = 0;
+    u_char * token_item = NULL;
+
+    if (value == NULL || begin > last || index == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    /*skip the first one which is a (*/
+    len =  value[begin].len - 1;
+    token_item = value[begin].data + 1;
+    while(begin <= last) {
+        while(len) {
+            if (*token_item == '(') {
+                match_score++;
+            } else if (*token_item == ')') {
+                match_score--;
+            }
+            len--;
+            token_item++;
+        }
+
+
+        /*Find the mathing*/
+        if (match_score ==0 ) {
+            *index = begin;
+            /*The one in begin +1 must be operator*/
+            return NGX_CONF_OK;
+        }
+
+        begin++;
+        /*try with next one.*/
+        len =  value[begin].len;
+        token_item = value[begin].data;
+    }
+    return NGX_CONF_ERROR;
+}
+
+static char *
+ngx_http_rewrite_parse_if_condition(ngx_conf_t *cf,
+        ngx_http_rewrite_loc_conf_t *lcf,
+        ngx_str_t *value, ngx_uint_t begin, ngx_uint_t last)
+{
+    ngx_uint_t index,ori_index;
+    ngx_http_rewrite_if_operator_t operator = {};
+    char * rv = NGX_CONF_OK;
+    ngx_http_script_if_op_e op_type =  ngx_http_script_if_invalid;
+    ngx_http_script_if_operator_code_t *operator_code;
+
+    /*find the matching )*/
+    if (value[begin].data[0] == '(') {
+        rv = ngx_http_rewrite_if_match_bracket(value, begin, last, &index);
+        if (rv != NGX_CONF_OK) {
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                    "find match bracket error.");
+            return rv;
+        }
+        ori_index = index;
+        if (value[begin].len == 1) {
+            begin++;
+        } else {
+            value[begin].len--;
+            value[begin].data++;
+        }
+        if (value[index].len == 1) {
+            index--;
+        } else {
+            value[index].data[value[index].len] = '\0';
+            value[index].len--;
+        }
+        /*The matching bracket is at the end of the tokens*/
+        rv = ngx_http_rewrite_parse_if_condition(cf, lcf, value, begin, index);
+        /*if op_type has validate value, then add the opcode*/
+        if (rv != NGX_CONF_OK) {
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                    "find parse if condition error.");
+            return rv;
+        }
+
+        index = ori_index;
+        if (index == last) {
+            return rv;
+        } else if (index < last - 2){
+            /*still have some tokens left.*/
+            /*The first one after index must be operator*/
+            op_type = ngx_http_rewrite_if_check_operator(&value[index + 1]);
+            if (op_type == ngx_http_script_if_invalid) {
+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                        "two subconditions are adjacent without logic operator.");
+                return NGX_CONF_ERROR;
+            }
+            begin = index + 2;
+            rv = ngx_http_rewrite_parse_if_condition(cf, lcf, value, begin, last);
+            if (rv != NGX_CONF_OK) {
+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                        "find parse if condition error.");
+                return rv;
+            }
+            operator.op_type = op_type;
+            operator.op_index = index;
+            /*add the operator operation here.*/
+            operator_code = ngx_array_push_n(lcf->codes,
+                    sizeof(ngx_http_script_if_operator_code_t));
+            operator_code->code = ngx_http_script_if_operator_code;
+            operator_code->op = op_type;
+            op_type = operator.op_type;
+            return rv;
+        } else {
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                    "if conditions parsing error.");
+            return NGX_CONF_ERROR;
+        }
+    } else {
+        /*Find the index of the operator*/
+        rv = ngx_http_rewrite_find_if_logic_operator(value, begin,
+                last, &operator);
+        if (rv != NGX_CONF_OK) {
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                    "internal if logic operator finding error.");
+            return rv;
+        }
+
+        /*no any opeators anymore*/
+        if (operator.op_type == ngx_http_script_if_invalid){
+            rv = ngx_http_rewrite_if_logic_item(cf, lcf, begin, last);
+            if (rv != NGX_CONF_OK) {
+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                        "internal if logic subcondition parsing error.");
+            }
+            return rv;
+
+        } else {
+            /*find the operator*/
+            rv = ngx_http_rewrite_if_logic_item(cf, lcf, begin, operator.op_index - 1);
+            if (rv != NGX_CONF_OK) {
+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                        "internal if logic subcondition parsing error.");
+                return rv;
+            }
+            begin = operator.op_index + 1;
+            rv = ngx_http_rewrite_parse_if_condition(cf, lcf, value, begin, last);
+            if (rv != NGX_CONF_OK) {
+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                        "internal if logic subcondition parsing error.");
+                return rv;
+            }
+            /*add the operator operation here.*/
+            operator_code = ngx_array_push_n(lcf->codes,
+                    sizeof(ngx_http_script_if_operator_code_t));
+            operator_code->code = ngx_http_script_if_operator_code;
+            operator_code->op = operator.op_type;
+            return rv;
+        }
+
+    }
+
+    return rv;
+}
+
+static char *
+ngx_http_rewrite_if_condition(ngx_conf_t *cf, ngx_http_rewrite_loc_conf_t *lcf)
+{
+    char                               *rv;
+    ngx_str_t                          *value;
+    ngx_uint_t                         begin, last;
+
+    value = cf->args->elts;
+    last = cf->args->nelts - 1;
+    begin = 1;
+
+    if (value[begin].len < 1 || value[begin].data[0] != '(') {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                           "invalid condition \"%V\"", &value[begin]);
+        return NGX_CONF_ERROR;
+    }
+
+
+    if (value[1].len == 1) {
+        begin = 2;
+    } else {
+        begin = 1;
+        value[1].len--;
+        value[1].data++;
+    }
+
+    /*The last one must be )*/
+    if (value[last].len < 1 || value[last].data[value[last].len - 1] != ')') {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                           "invalid condition \"%V\"", &value[last]);
+        return NGX_CONF_ERROR;
+    }
+
+    if (value[last].len == 1) {
+        last--;
+    } else {
+        value[last].len--;
+        value[last].data[value[last].len] = '\0';
+    }
+
+    rv = ngx_http_rewrite_parse_if_condition(cf, lcf, value, begin, last);
+
+    return rv;
+}
+

 static char *
 ngx_http_rewrite_variable(ngx_conf_t *cf, ngx_http_rewrite_loc_conf_t *lcf,
diff --git a/src/http/ngx_http_script.c b/src/http/ngx_http_script.c
index 13c57d6..5bcbf43 100644
--- a/src/http/ngx_http_script.c
+++ b/src/http/ngx_http_script.c
@@ -1853,6 +1853,45 @@ ngx_http_script_var_code(ngx_http_script_engine_t *e)
     e->sp++;
 }

+void
+ngx_http_script_if_operator_code(ngx_http_script_engine_t *e)
+{
+    ngx_http_script_if_operator_code_t  *code;
+    ngx_uint_t op;
+    ngx_http_variable_value_t  *val, *res;
+
+    code = (ngx_http_script_if_operator_code_t *) e->ip;
+    op = code->op;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                   "http script if operator %u", op);
+    e->sp--;
+    val = e->sp;
+    res = val;
+    res = e->sp - 1;
+
+    if ( op == ngx_http_script_if_and ) {
+        if ((val->len && (val->len != 1 || val->data[0] != '0')) && \
+            (res->len && (res->len != 1 || res->data[0] != '0'))) {
+            *res = ngx_http_variable_true_value;
+        } else {
+            *res = ngx_http_variable_null_value;
+        }
+    } else if ( op == ngx_http_script_if_or ) {
+        if ((val->len && (val->len != 1 || val->data[0] != '0')) || \
+            (res->len && (res->len != 1 || res->data[0] != '0'))) {
+            *res = ngx_http_variable_true_value;
+        } else {
+            *res = ngx_http_variable_null_value;
+        }
+    } else {
+        ngx_log_error(NGX_LOG_ERR, e->request->connection->log, 0,
+                "the operator %u isn't supported.", op);
+    }
+    e->ip += sizeof(ngx_http_script_if_operator_code_t);
+
+    return;
+}

 void
 ngx_http_script_nop_code(ngx_http_script_engine_t *e)
diff --git a/src/http/ngx_http_script.h b/src/http/ngx_http_script.h
index a6b345e..77651e6 100644
--- a/src/http/ngx_http_script.h
+++ b/src/http/ngx_http_script.h
@@ -179,13 +179,23 @@ typedef enum {
     ngx_http_script_file_not_exec
 } ngx_http_script_file_op_e;

-
 typedef struct {
     ngx_http_script_code_pt     code;
     uintptr_t                   op;
 } ngx_http_script_file_code_t;


+typedef enum {
+    ngx_http_script_if_invalid = -1,
+    ngx_http_script_if_and = 0,
+    ngx_http_script_if_or
+} ngx_http_script_if_op_e;
+
+typedef struct {
+    ngx_http_script_code_pt    code;
+    uintptr_t                  op;
+} ngx_http_script_if_operator_code_t;
+
 typedef struct {
     ngx_http_script_code_pt     code;
     uintptr_t                   next;
@@ -262,6 +272,7 @@ void ngx_http_script_set_var_code(ngx_http_script_engine_t *e);
 void ngx_http_script_var_set_handler_code(ngx_http_script_engine_t *e);
 void ngx_http_script_var_code(ngx_http_script_engine_t *e);
 void ngx_http_script_nop_code(ngx_http_script_engine_t *e);
+void ngx_http_script_if_operator_code(ngx_http_script_engine_t *e);


 #endif /* _NGX_HTTP_SCRIPT_H_INCLUDED_ */

